# 分布式服务接口的幂等性如何设计？
## 何为幂等性？
幂等（idempotence）来源于数学中的一个概念，例如：幂等函数/幂等方法（指用相同的参数重复执行，并能获得相同结果的函数，这些函数不影响系统状态，也不用担心重复执行会对系统造成改变）。即多次调用对系统的产生的影响是一样的，即对资源的作用是一样的。幂等性强调的是外界通过接口对系统内部的影响，只要一次或多次调用对某一个资源应该具有同样的副作用就行。

任意多次执行所产生的影响均与一次执行的影响相同，这是幂等性的核心特点。其实在我们编程中主要操作就是CURD，其中读取（Retrieve）操作和删除（Delete）操作是天然幂等的，受影响的就是创建（Create）、更新（Update）。

![](/images/分布式幂等/幂等性.jpeg)

## 幂等性主要场景有哪些？
根据上面对幂等性的定义得知：产生重复数据或数据不一致，这个绝大部分是由于发生了重复请求。这里的重复请求是指同一个请求在一些情况下被多次发起。导致这个情况会有哪些场景呢？

    （1）微服务架构下，不同微服务间会有大量的基于http、rpc或者mq消息的网络通信，会有第三个情况【未知】，也就是超时。如果超时了，微服务框架会进行重试。即接口超时重试
    （2）用户交互的时候多次点击，无意地触发多笔交易。即前端接口重复提交
    （3）MQ消息中间件，消息重复消费
    （4）第三方平台的接口（如：支付成功回调接口），因为异常也会导致多次异步回调
    （5）其他中间件/应用服务根据自身的特性，也有可能进行重试。
    
## 如何解决幂等性问题？
幂等性问题的解决方案有各种各样的解法，但是如何判断哪种解决方案对于自己的业务场景是最优解，这种情况下就需要抓问题本质。经过以上分析，得到了解决幂等性问题就是要控制对资源的写操作。从问题各个环节流程来分析解决：

![](/images/分布式幂等/幂等性问题分析.jpeg)

### 控制重复请求
控制动作触发源头，即前端做幂等性控制实现。但是相对不太可靠，没有从根本上解决问题，仅算作辅助解决方案。主要解决方案如下：

    （1）控制操作次数，例如：提交按钮仅可操作一次（提交动作后按钮置灰）
    （2）及时重定向，例如：下单/支付成功后跳转到成功提示页面，这样消除了浏览器前进或后退造成的重复提交问题。
    
### 过滤重复动作
控制过滤重复动作，是指在动作流转过程中控制有效请求数量。
#### 数据库去重表
往去重表里插入数据的时候，利用数据库的唯一索引特性，保证唯一的逻辑。唯一序列号可以是一个字段，例如订单的订单号，也可以是多字段的唯一性组合。例如设计如下的数据库表。
```
CREATE TABLE `t_idempotent` (
  `id` int(11) NOT NULL COMMENT 'ID',
  `serial_no` varchar(255)  NOT NULL COMMENT '唯一序列号',
  `source_type` varchar(255)  NOT NULL COMMENT '资源类型',
  `status` int(4) DEFAULT NULL COMMENT '状态',
  `remark` varchar(255)  NOT NULL COMMENT '备注',
  `create_by` bigint(20) DEFAULT NULL COMMENT '创建人',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `modify_by` bigint(20) DEFAULT NULL COMMENT '修改人',
  `modify_time` datetime DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`)
  UNIQUE KEY `key_s` (`serial_no`,`source_type`, `remark`)  COMMENT '保证业务唯一性'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='幂等性校验表';
```
注意看如下这几个关键性字段，

    （1）serial_no：唯一序列号的值，在这里我设置的是通过注解@IdempotentKey来标识请求对象中的字段，通过对他们 MD5 加密获取对应的值。
    （2）source_type：业务类型，区分不同的业务，订单，支付等。
    （3）remark：是由标识字段的拼接成的字符串，拼接符为 “|”。

由于数据建立了serial_no、source_type、remark三个字段组合构成的唯一索引，所以可以通过这个来去重达到接口的幂等性。
使用数据库防重表的方式它有个严重的缺点，那就是系统容错性不高，如果幂等表所在的数据库连接异常或所在的服务器异常，则会导致整个系统幂等性校验出问题。如果做数据库备份来防止这种情况，又需要额外忙碌一通了啊。

这种方法适用于在业务中有唯一标的插入场景中，比如在以上的支付场景中，如果一个订单只会支付一次，所以订单ID可以作为唯一标识。这时，我们就可以建一张去重表，并且把唯一标识作为唯一索引，在我们实现时，把创建支付单据和写入去去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。

#### 分布式锁（全局唯一ID）
利用Redis记录当前处理的业务标识（全局唯一ID），当检测到没有此任务在处理中，就进入处理，否则判为重复请求，可做过滤处理。

例如：订单发起支付请求，支付系统会去Redis缓存中查询是否存在该订单号的Key，如果不存在，则向Redis增加Key为订单号。查询订单支付已经支付，如果没有则进行支付，支付完成后删除该订单号的Key。通过Redis做到了分布式锁，只有这次订单订单支付请求完成，下次请求才能进来。

分布式锁相比去重表，将放并发做到了缓存中，较为高效。思路相同，同一时间只能完成一次支付请求。但是其实去重表与分布式锁本质都是采用全局唯一ID。使用全局唯一ID是一个通用方案，可以支持插入、更新、删除业务操作。但是这个方案看起来很美但是实现起来比较麻烦。

#### token令牌
针对前端重复连续多次点击的情况，例如用户购物提交订单，提交订单的接口就可以通过 Token 的机制实现防止重复提交。应用流程如下：

    （1）服务端提供了发送token的接口。执行业务前先去获取token，同时服务端会把token保存到redis中；
    （2）然后业务端发起业务请求时，把token一起携带过去，一般放在请求头部；
    （3）服务器判断token是否存在redis中，存在即第一次请求，可继续执行业务，执行业务完成后将token从redis中删除；
    （4）如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码不被重复执行。

![](/images/分布式幂等/token令牌处理流程.jpeg)

#### 状态机
对于很多业务是有一个业务流转状态的，每个状态都有前置状态和后置状态，以及最后的结束状态。例如流程的待审批，审批中，驳回，重新发起，审批通过，审批拒绝。订单的待提交，待支付，已支付，取消。
以订单为例，已支付的状态的前置状态只能是待支付，而取消状态的前置状态只能是待支付，通过这种状态机的流转就可以控制请求的幂等。假设当前状态是已支付，这时候如果支付接口又接收到了支付请求，则会抛异常或拒绝此次处理。
```
public enum OrderStatusEnum {

    UN_SUBMIT(0, 0, "待提交"),
    UN_PADING(0, 1, "待支付"),
    PAYED(1, 2, "已支付待发货"),
    DELIVERING(2, 3, "已发货"),
    COMPLETE(3, 4, "已完成"),
    CANCEL(0, 5, "已取消"),
    ;

    //前置状态
    private int preStatus;

    //状态值
    private int status;

    //状态描述
    private String desc;

    OrderStatusEnum(int preStatus, int status, String desc) {
        this.preStatus = preStatus;
        this.status = status;
        this.desc = desc;
    }

    //...
}
```
#### 缓冲队列
把所有请求都快速地接下来，对接入缓冲管道。后续使用异步任务处理管道中的数据，过滤掉重复的请求数据。

    （1）优点：同步转异步，实现高吞吐。
    （2）缺点：不能及时返回处理结果，需要后续监听处理结果的异步返回数据。
    
![](/images/分布式幂等/缓冲队列.jpeg)

### 解决重复写
实现幂等性常见的方式有：悲观锁（for update）、乐观锁、唯一约束。
#### 悲观锁（Pessimistic Lock）
简单理解就是：假设每一次拿数据，都有认为会被修改，所以给数据库的行或表上锁。
当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。

#### 乐观锁（Optimistic Lock）
简单理解就是：就是很乐观，每次去拿数据的时候都认为别人不会修改。更新时如果version变化了，更新不会成功。不过，乐观锁存在失效的情况，就是常说的ABA问题，不过如果version版本一直是自增的就不会出现ABA的情况。
```
UPDATE users SET name='xiaoxiao', version=(version+1) WHERE id=1 AND version=version;
```
#### 唯一约束
常见的就是利用数据库唯一索引或者全局业务唯一标识（如：source+序列号等）。这个机制是利用了数据库的主键唯一约束的特性，解决了在insert场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。

例如对外提供接口的api保证幂等就可以采用这种方式，如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号。source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)。

对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。
    
